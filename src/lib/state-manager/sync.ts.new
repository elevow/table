import { createHash } from 'crypto';
import { StateDelta } from '../../types/state';
import { TableState } from '../../types/poker';
import { ISyncManager, StateManagerConfig, VersionedState } from './types';

export class SyncManager implements ISyncManager {
  private syncTimeout: NodeJS.Timeout | null = null;
  private retryCount: number = 0;
  private syncTimer: ReturnType<typeof setTimeout> | null = null;
  
  constructor(
    private readonly config: StateManagerConfig,
    private readonly state: VersionedState<TableState>
  ) {}

  public startSyncInterval(): void {
    if (this.syncTimeout) {
      clearInterval(this.syncTimeout);
    }
    
    this.syncTimeout = setInterval(() => {
      this.syncState();
    }, this.config.syncInterval);
  }

  public stopSyncInterval(): void {
    if (this.syncTimeout) {
      clearInterval(this.syncTimeout);
      this.syncTimeout = null;
    }
    if (this.syncTimer) {
      clearTimeout(this.syncTimer);
      this.syncTimer = null;
    }
  }

  public async syncState(): Promise<void> {
    // Always clear retry timer before a sync attempt
    this.clearSyncTimer();

    try {
      const checksum = this.calculateChecksum(this.state.data);
      const pendingUpdates = Array.from(this.state.changes);

      if (this.retryCount >= this.config.retryAttempts) {
        // Max retries reached - emit failure and reset
        this.config.socket.emit('sync_failed', {
          version: this.state.version,
          timestamp: Date.now()
        });
        this.retryCount = 0;
        throw new Error('Max retry attempts reached');
      }

      const result = await this.config.socket.emit('sync_request', {
        version: this.state.version,
        checksum,
        pendingUpdates
      });

      if (!result) {
        throw new Error('Sync request failed');
      }

      // Successful sync - update timestamp and reset retry count
      this.state.lastSync = Date.now();
      this.retryCount = 0;
      
      // Only restart sync interval if we were in retry mode
      if (!this.syncTimeout) {
        this.startSyncInterval();
      }
    } catch (error) {
      // Increment retry count but don't retry immediately
      this.handleSyncError();
      throw error;
    }
  }

  public handleSyncError(): void {
    this.retryCount++;

    // Stop regular sync interval during retry mode
    if (this.syncTimeout) {
      clearInterval(this.syncTimeout);
      this.syncTimeout = null;
    }

    // Schedule next retry attempt
    this.syncTimer = setTimeout(() => {
      this.syncState();
    }, this.config.retryDelay);
  }

  private clearSyncTimer(): void {
    if (this.syncTimer) {
      clearTimeout(this.syncTimer);
      this.syncTimer = null;
    }
  }

  private calculateChecksum(data: any): string {
    const hash = createHash('md5');
    hash.update(JSON.stringify(data));
    return hash.digest('hex');
  }
}

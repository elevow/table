import { 
  registerServiceWorker, 
  isOffline, 
  sendToServiceWorker,
  getCacheStatus,
  clearAllCaches,
  unregisterServiceWorker
} from '../service-worker-registration';

// Setup mocks for browser objects
// Mock of ServiceWorkerRegistration
interface MockServiceWorkerRegistration {
  addEventListener: jest.Mock;
  installing: {
    addEventListener: jest.Mock;
    state: string;
  } | null;
  unregister: jest.Mock;
}

// Mock of ServiceWorker
interface MockServiceWorker {
  controller: {
    postMessage: jest.Mock;
  } | null;
  addEventListener: jest.Mock;
  getRegistration: jest.Mock;
  register: jest.Mock;
}

// Mock of Navigator with ServiceWorker
interface MockNavigator {
  serviceWorker: MockServiceWorker;
  onLine: boolean;
}

// Mock of Window
interface MockWindow {
  addEventListener: jest.Mock;
  location: {
    reload: jest.Mock;
  };
}

// Mock of Cache
interface MockCache {
  keys: jest.Mock;
  open: jest.Mock;
  delete: jest.Mock;
}

describe('Service Worker Registration', () => {
  // Define original objects to restore after tests
  let originalWindow: Window;
  let originalNavigator: Navigator;
  let originalCaches: CacheStorage;
  let originalConsole: Console;

  // Define mock objects
  let mockWindow: MockWindow;
  let mockNavigator: MockNavigator;
  let mockCaches: MockCache;
  let mockRegistration: MockServiceWorkerRegistration;
  let consoleLogSpy: jest.SpyInstance;
  let consoleErrorSpy: jest.SpyInstance;

  beforeEach(() => {
    // Store original objects
    originalWindow = global.window;
    originalNavigator = global.navigator;
    originalCaches = global.caches;
    originalConsole = global.console;

    // Create mock for service worker registration
    mockRegistration = {
      addEventListener: jest.fn(),
      installing: {
        addEventListener: jest.fn(),
        state: 'installed'
      },
      unregister: jest.fn().mockResolvedValue(true)
    };

    // Create mock for service worker
    const mockServiceWorker: MockServiceWorker = {
      controller: {
        postMessage: jest.fn()
      },
      addEventListener: jest.fn(),
      getRegistration: jest.fn().mockResolvedValue(mockRegistration),
      register: jest.fn().mockResolvedValue(mockRegistration)
    };

    // Create mock navigator
    mockNavigator = {
      serviceWorker: mockServiceWorker,
      onLine: true
    };

    // Create mock window
    mockWindow = {
      addEventListener: jest.fn(),
      location: {
        reload: jest.fn()
      }
    };

    // Create mock cache
    const mockCache = {
      keys: jest.fn().mockResolvedValue([
        { url: 'https://example.com/asset1.js' },
        { url: 'https://example.com/asset2.css' }
      ])
    };

    mockCaches = {
      keys: jest.fn().mockResolvedValue(['cache1', 'cache2']),
      open: jest.fn().mockResolvedValue(mockCache),
      delete: jest.fn().mockResolvedValue(true)
    };

    // Set up global mocks
    global.window = mockWindow as unknown as Window;
    global.navigator = mockNavigator as unknown as Navigator;
    global.caches = mockCaches as unknown as CacheStorage;

    // Spy on console methods
    consoleLogSpy = jest.spyOn(console, 'log').mockImplementation();
    consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();

    // Mock confirm to always return true
    global.confirm = jest.fn().mockReturnValue(true);
  });

  afterEach(() => {
    // Restore original objects
    global.window = originalWindow;
    global.navigator = originalNavigator;
    global.caches = originalCaches;
    global.console = originalConsole;

    // Clear all mocks
    jest.clearAllMocks();
    jest.restoreAllMocks();
  });

  describe('registerServiceWorker', () => {
    it('should register service worker on window load', () => {
      // Call the function to register service worker
      registerServiceWorker();

      // Get the load event callback
      const loadCallback = mockWindow.addEventListener.mock.calls[0][1];

      // Call the load callback
      loadCallback();

      // Verify service worker was registered
      expect(mockNavigator.serviceWorker.register).toHaveBeenCalledWith('/service-worker.js');
    });

    it('should handle registration success', () => {
      // Call the function to register service worker
      registerServiceWorker();

      // Get the load event callback and call it
      const loadCallback = mockWindow.addEventListener.mock.calls[0][1];
      loadCallback();

      // Verify service worker registration success was logged
      expect(consoleLogSpy).toHaveBeenCalledWith('SW registered: ', mockRegistration);
    });

    it('should handle registration error', async () => {
      // Set up registration to fail
      const error = new Error('Registration failed');
      mockNavigator.serviceWorker.register = jest.fn().mockRejectedValue(error);

      // Call the function to register service worker
      registerServiceWorker();

      // Get the load event callback and call it
      const loadCallback = mockWindow.addEventListener.mock.calls[0][1];
      await loadCallback();

      // Verify error was logged
      expect(consoleErrorSpy).toHaveBeenCalledWith('Service worker registration failed:', error);
    });

    it('should set up update handling', () => {
      // Call the function to register service worker
      registerServiceWorker();

      // Get the load event callback and call it
      const loadCallback = mockWindow.addEventListener.mock.calls[0][1];
      loadCallback();

      // Verify update listener was added
      expect(mockRegistration.addEventListener).toHaveBeenCalledWith('updatefound', expect.any(Function));

      // Get the updatefound callback
      const updateCallback = mockRegistration.addEventListener.mock.calls[0][1];

      // Call the updatefound callback
      updateCallback();

      // Verify state change listener was added to the installing worker
      expect(mockRegistration.installing?.addEventListener).toHaveBeenCalledWith('statechange', expect.any(Function));

      // Get the statechange callback
      const stateCallback = mockRegistration.installing?.addEventListener.mock.calls[0][1];

      // Set the state to installed and call the callback
      mockRegistration.installing!.state = 'installed';
      mockNavigator.serviceWorker.controller = { postMessage: jest.fn() };
      stateCallback();

      // Verify reload was called (because confirm returns true)
      expect(mockWindow.location.reload).toHaveBeenCalled();
    });

    it('should handle service worker messages', () => {
      // Call the function to register service worker
      registerServiceWorker();

      // Get the load event callback and call it
      const loadCallback = mockWindow.addEventListener.mock.calls[0][1];
      loadCallback();

      // Verify message listener was added
      expect(mockNavigator.serviceWorker.addEventListener).toHaveBeenCalledWith('message', expect.any(Function));

      // Get the message callback
      const messageCallback = mockNavigator.serviceWorker.addEventListener.mock.calls[0][1];

      // Test CACHE_UPDATED message
      messageCallback({ data: { type: 'CACHE_UPDATED', payload: 'Updated cache' } });
      expect(consoleLogSpy).toHaveBeenCalledWith('Cache updated:', 'Updated cache');

      // Test OFFLINE_READY message
      messageCallback({ data: { type: 'OFFLINE_READY' } });
      expect(consoleLogSpy).toHaveBeenCalledWith('App is ready for offline use');

      // Test CACHE_ERROR message
      messageCallback({ data: { type: 'CACHE_ERROR', payload: 'Cache error' } });
      expect(consoleErrorSpy).toHaveBeenCalledWith('Cache error:', 'Cache error');

      // Test unknown message
      messageCallback({ data: { type: 'UNKNOWN', payload: 'Unknown' } });
      // No additional console calls should happen
      expect(consoleLogSpy).toHaveBeenCalledTimes(2);
      expect(consoleErrorSpy).toHaveBeenCalledTimes(1);
    });

    it('should handle controller change', () => {
      // Call the function to register service worker
      registerServiceWorker();

      // Verify controllerchange listener was added
      expect(mockNavigator.serviceWorker.addEventListener).toHaveBeenCalledWith('controllerchange', expect.any(Function));

      // Get the controllerchange callback
      const controllerCallback = mockNavigator.serviceWorker.addEventListener.mock.calls[1][1];

      // Call the controllerchange callback
      controllerCallback();

      // Verify reload was called
      expect(mockWindow.location.reload).toHaveBeenCalled();

      // Call again to verify refreshing flag works
      controllerCallback();

      // Verify reload was called only once
      expect(mockWindow.location.reload).toHaveBeenCalledTimes(1);
    });

    it('should do nothing if service worker is not supported', () => {
      // Remove service worker support
      delete mockNavigator.serviceWorker;
      global.navigator = mockNavigator as unknown as Navigator;

      // Call the function to register service worker
      registerServiceWorker();

      // Verify no listeners were added
      expect(mockWindow.addEventListener).not.toHaveBeenCalled();
    });

    it('should do nothing if window is not defined', () => {
      // Set window to undefined
      global.window = undefined as unknown as Window;

      // Call the function to register service worker
      registerServiceWorker();

      // Verify no service worker registration was attempted
      expect(mockNavigator.serviceWorker?.register).not.toHaveBeenCalled();
    });
  });

  describe('isOffline', () => {
    it('should return true when navigator.onLine is false', () => {
      // Set offline status
      mockNavigator.onLine = false;
      global.navigator = mockNavigator as unknown as Navigator;

      // Check offline status
      expect(isOffline()).toBe(true);
    });

    it('should return false when navigator.onLine is true', () => {
      // Set online status
      mockNavigator.onLine = true;
      global.navigator = mockNavigator as unknown as Navigator;

      // Check offline status
      expect(isOffline()).toBe(false);
    });

    it('should handle when navigator is undefined', () => {
      // Set navigator to undefined
      global.navigator = undefined as unknown as Navigator;

      // Check offline status
      expect(isOffline()).toBe(false);
    });
  });

  describe('sendToServiceWorker', () => {
    it('should send message to service worker controller', () => {
      // Prepare test message
      const message = { type: 'TEST_MESSAGE', payload: 'test data' };

      // Send message
      sendToServiceWorker(message);

      // Verify message was sent
      expect(mockNavigator.serviceWorker.controller?.postMessage).toHaveBeenCalledWith(message);
    });

    it('should not send if controller is null', () => {
      // Remove controller
      mockNavigator.serviceWorker.controller = null;
      global.navigator = mockNavigator as unknown as Navigator;

      // Prepare test message
      const message = { type: 'TEST_MESSAGE', payload: 'test data' };

      // Send message
      sendToServiceWorker(message);

      // No errors should be thrown
      expect(true).toBe(true);
    });

    it('should not send if service worker is not supported', () => {
      // Remove service worker support
      delete mockNavigator.serviceWorker;
      global.navigator = mockNavigator as unknown as Navigator;

      // Prepare test message
      const message = { type: 'TEST_MESSAGE', payload: 'test data' };

      // Send message
      sendToServiceWorker(message);

      // No errors should be thrown
      expect(true).toBe(true);
    });

    it('should not send if navigator is undefined', () => {
      // Set navigator to undefined
      global.navigator = undefined as unknown as Navigator;

      // Prepare test message
      const message = { type: 'TEST_MESSAGE', payload: 'test data' };

      // Send message
      sendToServiceWorker(message);

      // No errors should be thrown
      expect(true).toBe(true);
    });
  });

  describe('getCacheStatus', () => {
    it('should return cache details when caches are available', async () => {
      // Call the function
      const status = await getCacheStatus();

      // Verify the correct status was returned
      expect(status).toEqual({
        available: true,
        caches: [
          {
            name: 'cache1',
            size: 2,
            urls: ['https://example.com/asset1.js', 'https://example.com/asset2.css']
          },
          {
            name: 'cache2',
            size: 2,
            urls: ['https://example.com/asset1.js', 'https://example.com/asset2.css']
          }
        ],
        totalCached: 4
      });

      // Verify cache methods were called
      expect(mockCaches.keys).toHaveBeenCalled();
      expect(mockCaches.open).toHaveBeenCalledTimes(2);
    });

    it('should handle when caches is undefined', async () => {
      // Set caches to undefined
      global.caches = undefined as unknown as CacheStorage;

      // Call the function
      const status = await getCacheStatus();

      // Verify the correct status was returned
      expect(status).toEqual({ available: false });
    });

    it('should handle errors when accessing caches', async () => {
      // Set up cache.keys to throw error
      const error = new Error('Cache access error');
      mockCaches.keys = jest.fn().mockRejectedValue(error);
      global.caches = mockCaches as unknown as CacheStorage;

      // Call the function
      const status = await getCacheStatus();

      // Verify the correct status was returned
      expect(status).toEqual({ available: false, error: error.message });
      expect(consoleErrorSpy).toHaveBeenCalledWith('Failed to get cache status:', error);
    });
  });

  describe('clearAllCaches', () => {
    it('should clear all caches when available', async () => {
      // Call the function
      const result = await clearAllCaches();

      // Verify all caches were cleared
      expect(result).toBe(true);
      expect(mockCaches.keys).toHaveBeenCalled();
      expect(mockCaches.delete).toHaveBeenCalledTimes(2);
      expect(mockCaches.delete).toHaveBeenCalledWith('cache1');
      expect(mockCaches.delete).toHaveBeenCalledWith('cache2');
    });

    it('should send notification to service worker', async () => {
      // Call the function
      await clearAllCaches();

      // Verify message was sent to service worker
      expect(mockNavigator.serviceWorker.controller?.postMessage).toHaveBeenCalledWith({
        type: 'CLEAR_ALL_CACHES'
      });
    });

    it('should handle when caches is undefined', async () => {
      // Set caches to undefined
      global.caches = undefined as unknown as CacheStorage;

      // Call the function
      const result = await clearAllCaches();

      // Verify the correct result was returned
      expect(result).toBe(false);
    });

    it('should handle errors when clearing caches', async () => {
      // Set up cache.delete to throw error
      const error = new Error('Cache deletion error');
      mockCaches.delete = jest.fn().mockRejectedValue(error);
      global.caches = mockCaches as unknown as CacheStorage;

      // Call the function
      const result = await clearAllCaches();

      // Verify the correct result was returned
      expect(result).toBe(false);
      expect(consoleErrorSpy).toHaveBeenCalledWith('Failed to clear caches:', error);
    });
  });

  describe('unregisterServiceWorker', () => {
    it('should unregister service worker when available', async () => {
      // Call the function
      const result = await unregisterServiceWorker();

      // Verify service worker was unregistered
      expect(result).toBe(true);
      expect(mockNavigator.serviceWorker.getRegistration).toHaveBeenCalled();
      expect(mockRegistration.unregister).toHaveBeenCalled();
    });

    it('should handle when service worker registration is not found', async () => {
      // Set registration to null
      mockNavigator.serviceWorker.getRegistration = jest.fn().mockResolvedValue(null);
      global.navigator = mockNavigator as unknown as Navigator;

      // Call the function
      const result = await unregisterServiceWorker();

      // Verify the correct result was returned
      expect(result).toBe(false);
    });

    it('should handle when service worker is not supported', async () => {
      // Remove service worker support
      delete mockNavigator.serviceWorker;
      global.navigator = mockNavigator as unknown as Navigator;

      // Call the function
      const result = await unregisterServiceWorker();

      // Verify the correct result was returned
      expect(result).toBe(false);
    });

    it('should handle when navigator is undefined', async () => {
      // Set navigator to undefined
      global.navigator = undefined as unknown as Navigator;

      // Call the function
      const result = await unregisterServiceWorker();

      // Verify the correct result was returned
      expect(result).toBe(false);
    });

    it('should handle errors when unregistering', async () => {
      // Set up getRegistration to throw error
      const error = new Error('Unregistration error');
      mockNavigator.serviceWorker.getRegistration = jest.fn().mockRejectedValue(error);
      global.navigator = mockNavigator as unknown as Navigator;

      // Call the function
      const result = await unregisterServiceWorker();

      // Verify the correct result was returned
      expect(result).toBe(false);
      expect(consoleErrorSpy).toHaveBeenCalledWith('Failed to unregister service worker:', error);
    });
  });
});
